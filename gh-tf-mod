#!/usr/bin/env bash
set -euo pipefail

GH_TF_MOD_VERSION='0.0.1'

# Default filesystem values
CONFIG="$HOME/.config/gh-tf-mod/config.json"
CACHE_ROOT="$HOME/.cache/gh-tf-mod"

# Defaults
SHOW_HELP=false
NO_CACHE=false
FORCE=false
YES_FLAG=false

check_for_required_deps() {
    if ! command -v jq >/dev/null 2>&1; then
        echo "jq is required to run gh-tf-mod"
        exit 1
    fi
}

check_for_required_deps

POSITIONAL_ARGS=()

while [[ $# -gt 0 ]]; do
  case $1 in
    -h|--help)
      COMMAND='help'
      SHOW_HELP=true
      shift
      ;;
    -v|--version)
      COMMAND='version'
      shift
      if [[ $# -gt 0 ]]; then
        VERSION="$1"
        shift
      fi
      ;;
    -c|--config)
      CONFIG="$2"
      shift 2
      ;;
    -o|--organization)
      ORG="$2"
      shift 2
      ;;
    -p|--provider)
      PROVIDER="$2"
      shift 2
      ;;
    --path)
      INSTALL_PATH="$2"
      shift 2
      ;;
    --no-cache)
      NO_CACHE=true
      shift
      ;;
    --force)
      FORCE=true
      shift
      ;;
    -y|--yes)
      YES_FLAG=true
      shift
      ;;
    -*)
      echo "Unknown option $1"
      exit 1
      ;;
    *)
      POSITIONAL_ARGS+=("$1") # save positional arg
      shift # past argument
      ;;
  esac
done

set -- "${POSITIONAL_ARGS[@]}" # restore positional args

set +u
if [[ -n $1 ]]; then
    COMMAND=$1
else
    [[ -z $COMMAND ]] && COMMAND='help'
fi
set -u

print_usage() {
cat <<- EOT
Usage:
    gh tf-mod [-hvopc] <command>

    flags:
        -h, --help          Prints help information
        -v, --version       Prints version information

    global flags:
        -o, --organization  The GitHub organization to use
        -p, --provider      The provider to use
        -c, --config        The path to the config file

    commands:
        ls
        add
        rm
        config
        version
        help
EOT
}

list_tf_modules() {
    local -r ORG="$1"
    gh api -X GET 'search/repositories' -f q='terraform-module in:name user:'"$ORG" --jq '.items[] | select(.name|startswith("terraform-")) | select(.name|endswith("-module")) | .name'
}

list_provider_modules() {
    local -r ORG="$1"
    local -r PROVIDER="$2"
    gh api -X GET 'search/repositories' -f q='terraform-'"$PROVIDER"'-module in:name user:'"$ORG" --jq '.items[] | select(.name|startswith("terraform-'"$PROVIDER"'-")) | select(.name|endswith("-module")) | .name'
}

create_config() {
    local ORG="$1"
    local PROVIDER="$2"

    [[ -n $ORG ]] || read -rp "Which organization would you like to use with gh-tf-mod? Leave blank to use your personal GitHub user: " ORG

    if [[ -z "$ORG" ]]; then
        ORG=$(gh api user --jq '.login')
        echo "Defaulting to logged in user: $ORG."
    fi

    mkdir -p "$(dirname "$CONFIG")"
    echo "{ \"organization\": \"$ORG\" }" | jq '.' > "$CONFIG"

    
    [[ -n $PROVIDER ]] || read -rp "Would you like to set a default provider? Leave blank to avoid setting a default provider: " PROVIDER

    if [[ -n $PROVIDER ]]; then
        tmp=$(mktemp)
        jq --arg provider "$PROVIDER" '.provider = $provider' "$CONFIG" > "$tmp"
        mv "$tmp" "$CONFIG"
    else
        echo "Not setting default provider. Use the -p/--provider flag to specify a provider manually."
    fi
}

get_provider() {
    set +u
    if [[ -z $PROVIDER ]]; then
        set -u
        if [[ -f $CONFIG ]]; then
            PROVIDER=$(jq -r '.provider' "$CONFIG")
        fi
    fi
    set +u
    [[ "$PROVIDER" == "null" ]] && PROVIDER=''
    echo "$PROVIDER"
    set -u
}

get_org() {
    set +u
    if [[ -z $ORG ]]; then
        set -u
        if [[ -f $CONFIG ]]; then
            jq -r '.organization' "$CONFIG"
        else
            gh api user --jq '.login'
        fi
    else
        echo "$ORG"
    fi
}

get_full_repo() {
    local -r MODULE_NAME="$1"
    ORG="$(get_org)"
    PROVIDER="$(get_provider)"
    FULL_REPO="$ORG/terraform"
    # If the provider is set, and it's not already the beginning of the module name, add it
    [[ -n $PROVIDER ]] && [[ ! "$MODULE_NAME" =~ "$PROVIDER".* ]] && FULL_REPO="$FULL_REPO-$PROVIDER"
    FULL_REPO="$FULL_REPO-$MODULE_NAME-module"
    echo "$FULL_REPO"
}

get_install_path() {
    local -r MODULE_NAME="$1"
    set +u
    if [[ -z $INSTALL_PATH ]]; then
        set -u
        if GIT_ROOT="$(git rev-parse --show-toplevel 2> /dev/null)"; then
            if [[ -f "$GIT_ROOT/submodules" ]]; then
                INSTALL_PATH="$GIT_ROOT/submodules/$MODULE_NAME"
            elif [[ -f "$GIT_ROOT/terragrunt/modules" ]]; then
                INSTALL_PATH="$GIT_ROOT/terragrunt/modules/$MODULE_NAME"
            else
                INSTALL_PATH="$GIT_ROOT/terraform/modules/$MODULE_NAME"
            fi
        else
            if [[ -f "submodules" ]]; then
                INSTALL_PATH="submodules/$MODULE_NAME"
            elif [[ -f "terragrunt/modules" ]]; then
                INSTALL_PATH="terragrunt/modules/$MODULE_NAME"
            else
                INSTALL_PATH="terraform/modules/$MODULE_NAME"
            fi
        fi
    fi
    echo "$INSTALL_PATH"
}

list_modules() {
    ORG="$(get_org)"
    PROVIDER="$(get_provider)"
    if [[ -n "$PROVIDER" ]]; then
        list_provider_modules "$ORG" "$PROVIDER"
    else
        list_tf_modules "$ORG"
    fi
}

list_module_latest() {
    local -r MODULE="$1"
    FULL_REPO="$(get_full_repo "$MODULE")"
    gh api -X GET "repos/$FULL_REPO/releases/latest" --jq '.tag_name'
}

list_module_releases() {
    local -r MODULE="$1"
    FULL_REPO="$(get_full_repo "$MODULE")"
    gh api -X GET "repos/$FULL_REPO/releases" --jq '.[].tag_name'
}

get_version() {
    local -r MODULE="$1"
    set +u
    if [[ -n $VERSION ]]; then
        set -u
        echo "$VERSION"
    else
        list_module_latest "$MODULE"
    fi
    set -u
}

install_module() {
    local -r FULL_REPO="$1"
    local -r VERSION="$2"
    local -r INSTALL_PATH="$3"

    mkdir -p "$INSTALL_PATH"

    if [[ $NO_CACHE == 'true' ]]; then
        tmpdir="$(mktemp -d)"
        trap "rm -f $tmpdir/release.tar.gz" EXIT
        gh -R "$FULL_REPO" release download -p 'release.tar.gz' -D "$tmpdir" "$VERSION"
        tar -xf "$tmpdir/release.tar.gz" -C "$INSTALL_PATH"
        rm -f "$tmpdir/release.tar.gz"
    elif [[ -f $CACHE_ROOT/releases/$FULL_REPO/$VERSION/release.tar.gz ]]; then
        tar -xf "$CACHE_ROOT/releases/$FULL_REPO/$VERSION/release.tar.gz" -C "$INSTALL_PATH"
    else
        gh -R "$FULL_REPO" release download -D "$CACHE_ROOT/releases/$FULL_REPO/$VERSION" -p 'release.tar.gz' "$VERSION"
        tar -xf "$CACHE_ROOT/releases/$FULL_REPO/$VERSION/release.tar.gz" -C "$INSTALL_PATH"
    fi
}

print_rm_usage() {
cat <<- EOT
Usage:
    gh tf-mod rm [-hfy] [<name>]

    flags:
        -h, --help          Prints help information.
        -f, --force         Force removal of a specific module, even if used.
        -y, --yes           Skip confirmation prompt.

    global flags:
        -p, --provider      The provider to target.

    name:
        The name of the module to remove. If not specified, every unused module will be removed.

        By default, a module in use cannot be deleted, and confirmation is required to delete a module.
        Use the -f/--force flag to force removal of a module that is in use, and the -y/--yes flag to skip the confirmation prompt.
EOT
}

is_module_used() {
    local -r MODULE="$1"
    local -r INSTALL_PATH="$2"
    GIT_ROOT="$(git rev-parse --show-toplevel 2> /dev/null)" && pushd "$GIT_ROOT" > /dev/null
    if grep -rn "source[^=]*=.*\/$MODULE\""; then
        echo "Module $MODULE is used at $INSTALL_PATH"
        return 0
    else
        return 1
    fi
}

confirm_module_deletion() {
    local -r MODULE="$1"
    if [[ "$YES_FLAG" == 'true' ]]; then
        return 0
    else
        read -rp "Are you sure you would like to delete the module $MODULE? Type 'yes' to confirm. " CONFIRMATION
        [[ $CONFIRMATION == 'yes' ]] && return 0
    fi
    return 1
}

delete_module_if_unused() {
    local -r MODULE="$1"
    local -r INSTALL_PATH="$2"
    local -r FORCE="$3"
    if [[ -d "$INSTALL_PATH" ]]; then
        if USED_MODULE_LOCATIONS="$(is_module_used "$MODULE" "$INSTALL_PATH")" && [[ "$FORCE" != 'true' ]]; then
            echo "Module $MODULE is used at $INSTALL_PATH. Use --force to remove it anyway."
            echo "$USED_MODULE_LOCATIONS"
            exit 1
        else
            if confirm_module_deletion "$MODULE"; then
                rm -rf "$INSTALL_PATH"
                echo "Removed $MODULE"
            else
                echo "Module $MODULE not removed."
            fi
        fi
    else
        echo "No module named $MODULE found"
        exit 1
    fi
}

delete_all_unused_modules() {
    local -r INSTALL_PATH="$1"
    pushd "$INSTALL_PATH" > /dev/null
    for MODULE in *; do
        delete_module_if_unused "$MODULE" "$INSTALL_PATH" 'false'
    done
}

handle_rm() {
    local -r MODULE="${1:-}"
    local -r INSTALL_PATH="$(get_install_path "$MODULE")"
    if [[ -n "$MODULE" ]]; then
        delete_module_if_unused "$MODULE" "$INSTALL_PATH" "$FORCE"
    else
        delete_all_unused_modules "$INSTALL_PATH"
    fi
}

print_list_usage() {
cat <<- EOT
Usage:
    gh tf-mod ls [-hopc] [<name>]

    flags:
        -h, --help          Prints help information
        -v, --version       List the versions available for a module

    global flags:
        -o, --organization  The GitHub organization to use
        -p, --provider      The provider to use
        -c, --config        The path to the config file

    name:
        The name of the module to list. If not specified, all modules will be listed.
        If specified without the -v flag, the latest version will be listed.
EOT
}

handle_list() {
    if [[ "$SHOW_HELP" == 'true' ]]; then
        print_list_usage
        exit 0
    fi
    set +u
    MODULE="$1"
    set -u
    if [[ -n "$MODULE" ]]; then
        list_module_releases "$MODULE"
    else
        list_modules
    fi
}

print_add_usage() {
cat <<- EOT
Usage:
    gh tf-mod add <module> [-hvopc] [--path|--version]

    flags:
        -h, --help          Prints help information
        --path              The local path to the module
        -v, --version       The version of the module to install

    global flags:
        -o, --organization  The GitHub organization to use
        -p, --provider      The provider to use
        -c, --config        The path to the config file
EOT
}

handle_add() {
    if [[ "$SHOW_HELP" == 'true' ]]; then
        print_add_usage
        exit 0
    fi
    : "${1:? 'Missing required argument $MODULE_NAME'}"
    MODULE_NAME="$1"
    VERSION="$(get_version "$MODULE_NAME")"
    INSTALL_PATH="$(get_install_path "$MODULE_NAME")"

    FULL_REPO="$(get_full_repo "$MODULE_NAME")"

    if gh api "repos/$FULL_REPO/releases/tags/$VERSION" &> /dev/null; then
        install_module "$FULL_REPO" "$VERSION" "$INSTALL_PATH"
    else
        echo "Failed to find release $FULL_REPO with tag $VERSION in GitHub"
    fi
}

print_config_usage() {
cat <<- EOT
Usage:
    gh tf-mod config [-hvopc]

    flags:
        -h, --help          Prints help information

    global flags:
        -o, --organization  The GitHub organization to use
        -p, --provider      The provider to use
        -c, --config        The path to the config file
EOT
}

handle_config() {
    if [[ "$SHOW_HELP" == 'true' ]]; then
        print_add_usage
        exit 0
    fi
    if [[ ! -f $CONFIG ]]; then
        echo "No config file found at $CONFIG. Creating..."
        set +u
        create_config "$ORG" "$PROVIDER"
        set -u
    else
        echo "Config file found at $CONFIG. Remove or select alternate config location to continue."
    fi
}

handle_help() {
    print_usage
}

handle_version() {
    echo "$GH_TF_MOD_VERSION"
}

case $COMMAND in
  config)
    shift
    handle_config
    ;;
  ls)
    shift
    handle_list "$@"
    ;;
  add)
    shift
    handle_add "$@"
    ;;
  rm)
    shift
    handle_rm "$@"
    ;;
  help)
    handle_help
    ;;
  version)
    handle_version
    ;;
  *)
    echo "Unknown command: $COMMAND"
    echo
    print_usage
    exit 1
    ;;
esac
